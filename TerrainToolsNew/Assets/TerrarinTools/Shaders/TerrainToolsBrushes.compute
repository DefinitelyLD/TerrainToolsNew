#if DEBUG
    #pragma enable_d3d11_debug_symbols
#endif


#pragma kernel RaiseBrush
#pragma kernel LowerBrush
#pragma kernel SmoothBrush
#pragma kernel FlatBrush
#pragma kernel EraseBrush

#pragma kernel StripsBrush
#pragma kernel RingsBrush
#pragma kernel CurveyStripsBrush
#pragma kernel SpiralBrush
#pragma kernel DoubleSpiralBrush
#pragma kernel PatternEraseBrush

#pragma kernel PaintBrush
#pragma kernel WaterRaiseBrush
#pragma kernel WaterLowerBrush

#pragma kernel MaskHeightmap
#pragma kernel Compose
#pragma kernel Tween
#pragma kernel ComputeNormals
#pragma kernel TessellateGridMesh

#pragma kernel TweenSplats

#pragma kernel GenerateCurrentmap
#pragma kernel SimulateWaterA
#pragma kernel SimulateWaterB
#pragma kernel SmoothCurrentmap

#define PI 3.14159265358979323846
#define EPSILON 1e-6

float WaterSimulationFactor = 1.0;

RWTexture2D<float> OutputDensitymapTexture;
RWTexture2D<float4> OutputPrepassDensityTexture;

Texture2D<float> DensitymapTexture;

RWTexture2D<float> OutputFoamMask;
Texture2D<float> FoamMaskTexture;

RWTexture2D<float4> OutputCurrentmap;
Texture2D<float4> CurrentmapTexture;

RWTexture2D<float4> OutputSplatmapTexture_0;
RWTexture2D<float4> OutputSplatmapTexture_1;

RWTexture2D<float4> OutputBrushSplatmapTexture_0;
RWTexture2D<float4> OutputBrushSplatmapTexture_1;

Texture2D<float4> SplatmapTexture_0;
Texture2D<float4> SplatmapTexture_1;

Texture2D<float4> TweenStateSplatmapTexture_0;
Texture2D<float4> TweenStateSplatmapTexture_1;

int SplatmapId;
int4 SplatmapChannelMask;

RWTexture2D<float4> NormalmapTexture;

float3 TerrainSize;

Texture2D<float> HeightmapMaskTexture;

Texture2D<float> HeightmapTexture;
Texture2D<float> TweenStateHeightmap;
Texture2D<float> CompositiveHeightmapTexture;

RWTexture2D<float> OutputHeightmapTexture;

Texture2D<float> BrushHeightmapTexture;
Texture2D<float> BrushMaskTexture;
RWTexture2D<float> OutputBrushHeightmapTexture;

SamplerState pointClampBrushMaskTextureSampler
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

int2 BrushPosition;

int2 BrushSize;
int2 ActualBrushSize;

float BrushStrength;
float BrushAngle;

float DeltaTime;

float BrushHeight;
float BrushStripCount;

float TweenStrength;

float2 GridMeshWorldPosition;
float2 GridHightmapTexelPosition;
uint2 GridCellCount;
float GridCellSize;

uint UseTessellationMask;
Texture2D<float> TessellationMaskTexture;

RWStructuredBuffer<float3> OutputMeshVertices;
RWStructuredBuffer<uint> OutputMeshIndices;
RWStructuredBuffer<float2> OutputMeshUVs;

float TerrainMaskBaseHeight;
float TerrainMaskBorder;

bool IsPointInRotatedBox(float2 boxPosition, int2 boxSize, float boxAngle, int2 target)
{
    // Convert angle to radians
    float angleRad = radians(-boxAngle);
    float cosAngle = cos(angleRad);
    float sinAngle = sin(angleRad);

    // Calculate half sizes of the box
    float halfWidth = boxSize.x / 2.0f;
    float halfHeight = boxSize.y / 2.0f;

    // Step 1: Translate the point into the box's local space by subtracting the box position
    int2 translatedPoint = target - boxPosition;

    // Step 2: Rotate the point by the inverse of the box's angle
    float rotatedX = translatedPoint.x * cosAngle + translatedPoint.y * sinAngle;
    float rotatedY = -translatedPoint.x * sinAngle + translatedPoint.y * cosAngle;

    // Step 3: Check if the rotated point is within the box's unrotated bounds
    bool isInside = (rotatedX >= -halfWidth && rotatedX <= halfWidth) &&
                    (rotatedY >= -halfHeight && rotatedY <= halfHeight);

    return isInside;
}

bool IsCulled(uint3 id)
{
    if ((int) id.x >= ActualBrushSize.x || (int) id.y >= ActualBrushSize.y)
    {
        return true;
    }
    
    if (IsPointInRotatedBox(ActualBrushSize * 0.5, BrushSize, BrushAngle, id.xy) == false)
    {
        return true;
    }
    
    return false;
}

float2 GetUV(uint3 id)
{
    // tranlating origin to the centre
    float2 pin = (float2) id - (ActualBrushSize * 0.5);

    // removing the current rotation or angle, on the texel.
    float mag = sqrt(pow(pin.x, 2.0) + pow(pin.y, 2.0));
    float theta = atan2(pin.y, pin.x) - radians(-BrushAngle);
    // texels at 0 degree rotation, and translating origin back to top left.
    float newX = mag * cos(theta) + (BrushSize.x * 0.5);
    float newY = mag * sin(theta) + (BrushSize.y * 0.5);

    // 0 - 1, ranging value, to sample sinosidal wave. its the texel position relative to its max or last position.
    float2 uv = float2(newX / (float) BrushSize.x, newY / (float) BrushSize.y);
    
    return uv;
}

float GetBrushMaskValue(uint3 id)
{
    float2 uv = GetUV(id);
    
    float color = BrushMaskTexture.SampleLevel(pointClampBrushMaskTextureSampler, uv, 0);
    return color;
}

[numthreads(32, 32,1)]
void RaiseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight += BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void LowerBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight -= BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void SmoothBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    if (mask == 0.0)
    {
        return;
    }
    
    float accumulation = 0;
    uint sampleCount = 0;
    
    for (int y = -BrushStrength; y < BrushStrength + 1; y++)
    {
        for (int x = -BrushStrength; x < BrushStrength + 1; x++)
        {
            int3 index = int3(id.x + x, id.y + y, 0);
            
            if (index.x < 0 || index.x >= ActualBrushSize.x || index.y < 0 || index.y >= ActualBrushSize.y)
            {
                continue;
            }
            
            accumulation += BrushHeightmapTexture.Load(index);
            sampleCount++;
        }
    }
    
    float newHeight = accumulation / (float)sampleCount;
    
    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void FlatBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight = BrushHeight * mask;
    currentHeight = clamp(currentHeight, 0, BrushHeight);
    
    currentHeight = clamp(currentHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void EraseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    
    if (mask == 0.0)
    {
        return;
    }
    
    float newHeight = 0;
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void StripsBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
     
    float mask = GetBrushMaskValue(id);
    mask = mask > 0.0? 1.0 : 0.0;
    
    float2 uv = GetUV(id);
    uv.y = clamp(uv.y, 0, 1);
    
    float wave = sqrt(max(sin(uv.y * (BrushStripCount + 0.5) * PI * 2.0), 0));

    float newHeight = (wave * BrushHeight) * mask;

    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void RingsBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
     
    float mask = GetBrushMaskValue(id);
    mask = mask > 0.0 ? 1.0 : 0.0;
    
    float2 uv = GetUV(id);
    uv.y = clamp(uv.y, 0, 1);
    
    float wave = sqrt(max(sin(uv.y * (BrushStripCount + 0.5) * PI * 2.0), 0));

    float newHeight = (wave * BrushHeight) * mask;

    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void CurveyStripsBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
     
    float mask = GetBrushMaskValue(id);
    mask = mask > 0.0 ? 1.0 : 0.0;
    
    float2 uv = GetUV(id);
    uv.y = clamp(uv.y, 0, 1);
    
    float wave = sqrt(max(sin(uv.y * (BrushStripCount + 0.5) * PI * 2.0), 0));

    float newHeight = (wave * BrushHeight) * mask;

    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void SpiralBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
     
    // tranlating origin to the centre
    float2 pin = (float2) id.xy - (ActualBrushSize * 0.5f);
    float mag = sqrt(pow(pin.x, 2.0) + pow(pin.y, 2.0));

    // if it lies in dot radius.
    if (mag > ActualBrushSize.x * 0.5f)
        return;

    // 0 to 1 value to samples, i.e to most left to most right,
    float norm = 1.0 - (mag / (ActualBrushSize.x * 0.5f));
    // the new height to set
    float height = BrushHeight * (sqrt(norm));
    
    float currentHeight = OutputBrushHeightmapTexture[id.xy];

    // do not degrade the already applied high position, else it will add height, then on next step remove height
    if (currentHeight >= height)
        return;
        
    OutputBrushHeightmapTexture[id.xy] = height;
}

[numthreads(32, 32, 1)]
void DoubleSpiralBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
     
    // tranlating origin to the centre
    float2 pin = (float2) id.xy - (ActualBrushSize * 0.5f);
    float mag = sqrt(pow(pin.x, 2.0) + pow(pin.y, 2.0));

    // if it lies in dot radius.
    if (mag > ActualBrushSize.x * 0.5f)
        return;

    // 0 to 1 value to samples, i.e to most left to most right,
    float norm = 1.0 - (mag / (ActualBrushSize.x * 0.5f));
    // the new height to set
    float height = BrushHeight * (sqrt(norm));
    
    float currentHeight = OutputBrushHeightmapTexture[id.xy];

    // do not degrade the already applied high position, else it will add height, then on next step remove height
    if (currentHeight >= height)
        return;
        
    OutputBrushHeightmapTexture[id.xy] = height;
}

[numthreads(32,32,1)]
void PatternEraseBrush(uint3 id: SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    
    if (mask == 0.0)
    {
        return;
    }
    
    float newHeight = 0;
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void PaintBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    
    if (SplatmapId < 4)
    {
        float4 current = OutputBrushSplatmapTexture_0[id.xy];
        current += BrushStrength * mask * float4(SplatmapChannelMask) * DeltaTime;
        current -= BrushStrength * mask * float4(1 - SplatmapChannelMask) * DeltaTime;
           
        current = clamp(current, 0, 1);
        OutputBrushSplatmapTexture_0[id.xy] = current;
    }
    else
    {
        float4 current = OutputBrushSplatmapTexture_1[id.xy];
        current += BrushStrength * mask * float4(SplatmapChannelMask) * DeltaTime;
        current -= BrushStrength * mask * float4(1 - SplatmapChannelMask) * DeltaTime;
        
        current = clamp(current, 0, 1);
        OutputBrushSplatmapTexture_1[id.xy] = current;
    }
}

[numthreads(32, 32, 1)]
void WaterRaiseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return; 
    }
    
    float mask = GetBrushMaskValue(id);
    
    
    float current = OutputBrushHeightmapTexture[id.xy];
    current += BrushStrength * DeltaTime * mask;
    
    current = clamp(current, 0, 1);
    OutputBrushHeightmapTexture[id.xy] = current;
}

[numthreads(32, 32, 1)]
void WaterLowerBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    
    
    float current = OutputBrushHeightmapTexture[id.xy];
    current -= BrushStrength * DeltaTime * mask;
    
    current = clamp(current, 0, 1);
    OutputBrushHeightmapTexture[id.xy] = current;
}


[numthreads(32, 32, 1)]
void MaskHeightmap(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
        return;

    int2 center = int2(id.x, id.y);
    const int border = TerrainMaskBorder;
    bool forceMask = false;

    // Cardinal direction offsets
    int2 offsets[4] =
    {
        int2(0, border), // top
        int2(0, -border), // bottom
        int2(border, 0), // right
        int2(-border, 0) // left
    };

    // Clamp offsets once before sampling
    float mask = 1;
    [unroll]
    for (int i = 0; i < 4; ++i)
    {
        int2 pos = clamp(center + offsets[i], int2(0, 0), int2(limits) - 1);
        float maskVal = HeightmapMaskTexture.Load(int3(pos, 0));
        if (maskVal == 0.0f)
        {
            mask = 0;
            break;
        }
    }

    float height = HeightmapTexture.Load(int3(center, 0));

    float newHeight = (height * mask) + TerrainMaskBaseHeight;
    OutputHeightmapTexture[center] = newHeight;
}


[numthreads(32, 32, 1)]
void Compose(uint3 id : SV_DispatchThreadID)
{   
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float baseHeight = HeightmapTexture.Load(int3(id.x, id.y, 0));
    float compositiveHeight = CompositiveHeightmapTexture.Load(int3(id.x, id.y, 0));
    
    float newHeight = baseHeight + compositiveHeight;
    
    //newHeight = clamp(newHeight, 0, 0.5);
    OutputHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void Tween(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float targetHeight = HeightmapTexture.Load(int3(id.x, id.y, 0));
    float currentHeight = TweenStateHeightmap.Load(int3(id.x, id.y, 0));
    
    float newHeight = lerp(currentHeight, targetHeight, DeltaTime * TweenStrength);
    
    //newHeight = clamp(newHeight, 0, 0.5);
    OutputHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32,1)]
void ComputeNormals(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }

    int2 p = int2(id.xy);

    float hL = HeightmapTexture.Load(int3(p + int2(-1, 0), 0));
    float hR = HeightmapTexture.Load(int3(p + int2(1, 0), 0));
    float hD = HeightmapTexture.Load(int3(p + int2(0, -1), 0));
    float hU = HeightmapTexture.Load(int3(p + int2(0, 1), 0));

    float dx = (hL - hR) * TerrainSize.x;
    float dy = 2.0 * TerrainSize.y;
    float dz = (hD - hU) * TerrainSize.z;

    float3 normal = normalize(float3(dx, dy, dz));
    NormalmapTexture[p] = float4(normal * 0.5 + 0.5, 1.0); // Convert to [0,1] range
    
    //float3 normal = normalize(float3(dx, dy, dz));
    //float3 encoded = normal * 0.5 + 0.5; // [-1,1] to [0,1]

    //// Swizzle to match A2B10G10R10 layout: R -> Z, G -> Y, B -> X
    //NormalmapTexture[p] = float4(encoded.z, encoded.y, encoded.x, 1.0);
}

[numthreads(32, 32, 1)]
void TessellateGridMesh(uint3 id: SV_DispatchThreadID)
{
    uint gridWidth = GridCellCount.x + 1;
    uint gridHeight = GridCellCount.y + 1;

    if (id.x >= gridWidth || id.y >= gridHeight)
        return;

    uint vertexIndex = id.y * gridWidth + id.x;

    // Compute world position
    float xPos = GridMeshWorldPosition.x + (id.x * GridCellSize);
    float zPos = GridMeshWorldPosition.y + (id.y * GridCellSize);

    // Compute UV (for visualization / texturing)
    float u = (float) id.x / GridCellCount.x;
    float v = (float) id.y / GridCellCount.y;
    
    OutputMeshUVs[vertexIndex] = float2(u, v);
    OutputMeshVertices[vertexIndex] = float3(xPos, 0, zPos);

    // Skip triangle generation if on last row/column
    if (id.x >= GridCellCount.x || id.y >= GridCellCount.y)
        return;

    // Triangle indices
    uint baseVertex = id.y * gridWidth + id.x;
    uint baseIndex = (id.y * GridCellCount.x + id.x) * 6;

    uint i0 = baseVertex;
    uint i1 = baseVertex + 1;
    uint i2 = baseVertex + gridWidth;
    uint i3 = baseVertex + gridWidth + 1;

    if (UseTessellationMask == 1)
    {
        float mask = TessellationMaskTexture.Load(int3(id.x, id.y, 0));
        if (mask > 0.0)
        {
            OutputMeshIndices[baseIndex + 0] = i0;
            OutputMeshIndices[baseIndex + 1] = i1;
            OutputMeshIndices[baseIndex + 2] = i2;

            OutputMeshIndices[baseIndex + 3] = i1;
            OutputMeshIndices[baseIndex + 4] = i3;
            OutputMeshIndices[baseIndex + 5] = i2;
            
            return;
        }
    }
    OutputMeshIndices[baseIndex + 0] = i0;
    OutputMeshIndices[baseIndex + 1] = i2;
    OutputMeshIndices[baseIndex + 2] = i1;

    OutputMeshIndices[baseIndex + 3] = i1;
    OutputMeshIndices[baseIndex + 4] = i2;
    OutputMeshIndices[baseIndex + 5] = i3;
}

[numthreads(32, 32, 1)]
void TweenSplats(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    SplatmapTexture_0.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float4 target0 = SplatmapTexture_0.Load(int3(id.x, id.y, 0));
    float4 target1 = SplatmapTexture_1.Load(int3(id.x, id.y, 0));
    
    float4 current0 = TweenStateSplatmapTexture_0.Load(int3(id.x, id.y, 0));
    float4 current1 = TweenStateSplatmapTexture_1.Load(int3(id.x, id.y, 0));
    
    float4 new0 = lerp(current0, target0, DeltaTime * TweenStrength);
    float4 new1 = lerp(current1, target1, DeltaTime * TweenStrength);

    OutputBrushSplatmapTexture_0[id.xy] = new0;
    OutputBrushSplatmapTexture_1[id.xy] = new1;
}
float SampleSafe(int x, int y, uint2 limits, float current)
{
    if (x < 0 || y < 0 || x >= (int)limits.x || y >= (int) limits.y)
    {
        return current;
    }

    return HeightmapTexture.Load(int3(x, y, 0)) + DensitymapTexture.Load(int3(x, y, 0));
}
[numthreads(32, 32, 1)]
void GenerateCurrentmap(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);

    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }

    int x = (int) id.x;
    int y = (int) id.y;

    float current = HeightmapTexture.Load(int3(x, y, 0)) + DensitymapTexture.Load(int3(x, y, 0));

    float neighbors[8] =
    {
        SampleSafe(x, y + 1, limits, current), // Top
        SampleSafe(x, y - 1, limits, current), // Bottom
        SampleSafe(x + 1, y, limits, current), // Right
        SampleSafe(x - 1, y, limits, current), // Left
        SampleSafe(x + 1, y + 1, limits, current), // Top-Right
        SampleSafe(x - 1, y + 1, limits, current), // Top-Left
        SampleSafe(x + 1, y - 1, limits, current), // Bottom-Right
        SampleSafe(x - 1, y - 1, limits, current) // Bottom-Left
    };

    float differences[9] =
    {
        0, 0, 0, 0, 0, 0, 0, 0, 0
    };

    float4 currents[9] =
    {
        float4(0, 0, 1, 1), // center
        float4(0.5, 1, 1, 1), // top
        float4(0.5, 0, 1, 1), // bottom
        float4(1, 0.5, 1, 1), // right
        float4(0, 0.5, 1, 1), // left
        float4(0.75, 0.75, 1, 1), // top-right
        float4(0.25, 0.75, 1, 1), // top-left
        float4(0.75, 0.25, 1, 1), // bottom-right
        float4(0.25, 0.25, 1, 1) // bottom-left
    };

    for (uint i = 0; i < 8; i++)
    {
        differences[i + 1] = max(current - neighbors[i], 0);
    }

    uint index = 0;
    for (uint q = 1; q < 9; q++)
    {
        if (differences[q] > differences[index])
        {
            index = q;
        }
    }

    float foam = (differences[index] / max(current, EPSILON)) * 16;

    OutputCurrentmap[id.xy] = currents[index];
    OutputFoamMask[id.xy] = foam;
}


[numthreads(32, 32, 1)]
void SimulateWaterA(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    OutputPrepassDensityTexture.GetDimensions(limits.x, limits.y);
    
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float quantity = DensitymapTexture.Load(int3(id.x, id.y, 0));
    float height = HeightmapTexture.Load(int3(id.x, id.y, 0)) * 2;
    float mask = step(EPSILON, HeightmapMaskTexture.Load(int3(id.x, id.y, 0)));
    
    if (mask == 0)
    {
        return;
    }
    
    float maskTop     = (int)id.y + 1     >= (int)limits.y    ? +mask : HeightmapMaskTexture.Load(int3(id.x, id.y + 1, 0));
    float maskBottom  = (int)id.y - 1     < 0                 ? +mask : HeightmapMaskTexture.Load(int3(id.x, id.y - 1, 0));
    float maskRight   = (int)id.x + 1     >= (int)limits.x    ? +mask : HeightmapMaskTexture.Load(int3(id.x + 1, id.y, 0));
    float maskLeft    = (int)id.x - 1     < 0                 ? +mask : HeightmapMaskTexture.Load(int3(id.x - 1, id.y, 0));    
    
    float top     = (int)id.y + 1     >= (int)limits.y    ? +quantity : DensitymapTexture.Load(int3(id.x, id.y + 1, 0));
    float bottom  = (int)id.y - 1     < 0                 ? +quantity : DensitymapTexture.Load(int3(id.x, id.y - 1, 0));
    float right   = (int)id.x + 1     >= (int)limits.x    ? +quantity : DensitymapTexture.Load(int3(id.x + 1, id.y, 0));
    float left    = (int)id.x - 1     < 0                 ? +quantity : DensitymapTexture.Load(int3(id.x - 1, id.y, 0));
    
    float heightTop     = (int)id.y + 1     >= (int)limits.y    ? +height : HeightmapTexture.Load(int3(id.x, id.y + 1, 0)) * 2;
    float heightBottom  = (int)id.y - 1     < 0                 ? +height : HeightmapTexture.Load(int3(id.x, id.y - 1, 0)) * 2;
    float heightRight   = (int)id.x + 1     >= (int)limits.x    ? +height : HeightmapTexture.Load(int3(id.x + 1, id.y, 0)) * 2;
    float heightLeft    = (int)id.x - 1     < 0                 ? +height : HeightmapTexture.Load(int3(id.x - 1, id.y, 0)) * 2;
    
    float deltaQuantity[4] =
    {
        (quantity - top)    * maskTop,
        (quantity - bottom) * maskBottom,
        (quantity - right)  * maskRight,
        (quantity - left)   * maskLeft

    };
    
    float deltaHeights[4] =
    {
        (height - heightTop)    * maskTop,
        (height - heightBottom) * maskBottom,
        (height - heightRight)  * maskRight,
        (height - heightLeft)   * maskLeft

    };

    uint partners = 1;
    for (uint q = 0; q < 4; q++)
    {
        deltaQuantity[q] = max(deltaQuantity[q], 0);
        deltaHeights[q] = max(deltaHeights[q], 0);
        
        float deltaSurface = deltaHeights[q] + deltaQuantity[q];
        if (deltaSurface > 0)
        {
            partners++;
        }
       
    }
    
    float maxChange = quantity / 4;
    
    float prepassResult[4] = { 0, 0, 0, 0 };
    
    const float spreadSpeed = 64;
    const float deltaTime = 0.016;
    
    for (uint p = 0; p < 4; p++)
    {
        float deltaSurface = deltaHeights[p] + deltaQuantity[p];
        float surface = height + quantity;

        float norm = (deltaSurface / max(surface, EPSILON));
        float change = maxChange * norm;
            
        change *= deltaTime * spreadSpeed;
        change *= WaterSimulationFactor;

        prepassResult[p] = change;
        
        OutputDensitymapTexture[id.xy] -= change;
    }

    OutputPrepassDensityTexture[id.xy] = float4(prepassResult[0], prepassResult[1], prepassResult[2], prepassResult[3]);
}

[numthreads(32,32,1)]
void SimulateWaterB(uint3 id : SV_DispatchThreadId)
{
    uint2 limits;
    OutputDensitymapTexture.GetDimensions(limits.x, limits.y);
    
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float4 top;
    float4 bottom;
    float4 right;
    float4 left;
    
    top     = (int) id.y + 1 >= (int) limits.y  ? float4(0, 0, 0, 0) : OutputPrepassDensityTexture[int2(id.x,     id.y + 1)];
    bottom  = (int) id.y - 1 < 0                ? float4(0, 0, 0, 0) : OutputPrepassDensityTexture[int2(id.x,     id.y - 1)];
    right   = (int) id.x + 1 >= (int) limits.x  ? float4(0, 0, 0, 0) : OutputPrepassDensityTexture[int2(id.x + 1, id.y)];
    left    = (int) id.x - 1 < 0                ? float4(0, 0, 0, 0) : OutputPrepassDensityTexture[int2(id.x - 1, id.y)];
    
    float change = top.g + bottom.r + right.a + left.b;
    
    //OutputFoamMask[id.xy] += change * 64;
    OutputDensitymapTexture[id.xy] += change;
}

[numthreads(32, 32, 1)]
void SmoothCurrentmap(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    CurrentmapTexture.GetDimensions(limits.x, limits.y);

    // Early exit if outside of texture bounds
    if (id.x >= limits.x || id.y >= limits.y)
        return;

    const int strength = 16; // 33x33 window
    const int kernelSize = (2 * strength + 1); // 33x33

    float4 accumulation = 0;
    float foamAcc = 0;
    uint sampleCount = 0;
    uint foamSampleCount = 0;

    // Min and max clamping to ensure within bounds
    int minX = max(0, id.x - strength);
    int maxX = min(limits.x, id.x + strength + 1);
    int minY = max(0, id.y - strength);
    int maxY = min(limits.y, id.y + strength + 1);

    // Combine both loops into one
    for (int y = minY; y < maxY; ++y)
    {
        for (int x = minX; x < maxX; ++x)
        {
            int3 coord = int3(x, y, 0);

            // Check if heightmap mask is valid (non-zero)
            float mask = step(EPSILON, HeightmapMaskTexture.Load(coord));
            if (mask == 0)
                continue;

            // Accumulate values for averaging
            accumulation += CurrentmapTexture.Load(coord);
            foamAcc += FoamMaskTexture.Load(coord);

            ++sampleCount;
            ++foamSampleCount;
        }
    }

    // Ensure we don't divide by zero
    float4 newCurrent = (sampleCount > 0) ? (accumulation / sampleCount) : float4(0, 0, 0, 0);
    float newFoam = (foamSampleCount > 0) ? (foamAcc / foamSampleCount) : 0.0;

    // Output the final smoothed values
    OutputCurrentmap[id.xy] = newCurrent;
    OutputFoamMask[id.xy] = newFoam;
}