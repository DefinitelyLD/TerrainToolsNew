#pragma kernel RaiseBrush
#pragma kernel LowerBrush
#pragma kernel SmoothBrush
#pragma kernel FlatBrush
#pragma kernel EraseBrush

#pragma kernel StripsBrush
#pragma kernel RingsBrush
#pragma kernel CurveyStripsBrush
#pragma kernel SpiralBrush
#pragma kernel DoubleSpiralBrush
#pragma kernel PatternEraseBrush

#pragma kernel PaintBrush
#pragma kernel WaterBrush

#pragma kernel MaskHeightmap
#pragma kernel Compose
#pragma kernel Tween
#pragma kernel ComputeNormals
#pragma kernel TessellateGridMesh

#define PI 3.14159265358979323846
#define PATTERN_UV_REDZONE 8.0

RWTexture2D<float4> NormalmapTexture;

float3 TerrainSize;

Texture2D<float> HeightmapMaskTexture;

Texture2D<float> HeightmapTexture;
Texture2D<float> TweenStateHeightmap;
Texture2D<float> CompositiveHeightmapTexture;

RWTexture2D<float> OutputHeightmapTexture;

Texture2D<float> BrushHeightmapTexture;
Texture2D<float> BrushMaskTexture;
RWTexture2D<float> OutputBrushHeightmapTexture;

SamplerState pointClampBrushMaskTextureSampler
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

int2 BrushPosition;

int2 BrushSize;
int2 ActualBrushSize;

float BrushStrength;
float BrushAngle;

float DeltaTime;

float BrushHeight;
int BrushStripCount;

float TweenStrength;

float2 GridMeshWorldPosition;
float2 GridHightmapTexelPosition;
uint2 GridCellCount;
float GridCellSize;

RWStructuredBuffer<float3> OutputMeshVertices;
RWStructuredBuffer<uint> OutputMeshIndices;
RWStructuredBuffer<float2> OutputMeshUVs;

float2 RotateUV(float2 uv, float angleDegrees)
{
    float angleRadians = radians(angleDegrees);

    uv -= 0.5;

    float cosA = cos(angleRadians);
    float sinA = sin(angleRadians);

    float2 rotatedUV;
    rotatedUV.x = uv.x * cosA - uv.y * sinA;
    rotatedUV.y = uv.x * sinA + uv.y * cosA;

    rotatedUV += 0.5;

    return rotatedUV;
}

float2 UVFromId(uint3 id, float redZone)
{
    float2 offset = (ActualBrushSize - BrushSize) * 0.5;
    offset += redZone;
    float2 uv = (float2(id.xy) - offset) / float2(BrushSize - redZone);
    
    return uv;
}

bool IsPointInRotatedBox(float2 boxPosition, int2 boxSize, float boxAngle, int2 target)
{
    // Convert angle to radians
    float angleRad = radians(boxAngle);
    float cosAngle = cos(angleRad);
    float sinAngle = sin(angleRad);

    // Calculate half sizes of the box
    float halfWidth = boxSize.x / 2.0f;
    float halfHeight = boxSize.y / 2.0f;

    // Step 1: Translate the point into the box's local space by subtracting the box position
    int2 translatedPoint = target - boxPosition;

    // Step 2: Rotate the point by the inverse of the box's angle
    float rotatedX = translatedPoint.x * cosAngle + translatedPoint.y * sinAngle;
    float rotatedY = -translatedPoint.x * sinAngle + translatedPoint.y * cosAngle;

    // Step 3: Check if the rotated point is within the box's unrotated bounds
    bool isInside = (rotatedX >= -halfWidth && rotatedX <= halfWidth) &&
                    (rotatedY >= -halfHeight && rotatedY <= halfHeight);

    return isInside;
}

bool IsCulled(uint3 id)
{
    if ((int) id.x >= ActualBrushSize.x || (int) id.y >= ActualBrushSize.y)
    {
        return true;
    }
    
    if (IsPointInRotatedBox(ActualBrushSize * 0.5, BrushSize, BrushAngle, id.xy) == false)
    {
        return true;
    }
    
    return false;
}

float GetBrushMaskValue(uint3 id)
{
    float2 uv = UVFromId(id, 0);
    uv = RotateUV(uv, BrushAngle);
    
    float color = BrushMaskTexture.SampleLevel(pointClampBrushMaskTextureSampler, uv, 0);
    return color;
}

[numthreads(32, 32,1)]
void RaiseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight += BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void LowerBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight -= BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void SmoothBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    
    float accumulation = 0;
    uint sampleCount = 0;
    
    for (int y = -BrushStrength; y < BrushStrength + 1; y++)
    {
        for (int x = -BrushStrength; x < BrushStrength + 1; x++)
        {
            int3 index = int3(id.x + x, id.y + y, 0);
            
            if (index.x < 0 || index.x >= ActualBrushSize.x || index.y < 0 || index.y >= ActualBrushSize.y)
            {
                continue;
            }
            
            accumulation += BrushHeightmapTexture.Load(index);
            sampleCount++;
        }
    }
    
    float newHeight = accumulation / (float)sampleCount;
    
    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void FlatBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight = BrushHeight * mask;
    currentHeight = clamp(currentHeight, 0, BrushHeight);
    
    currentHeight = clamp(currentHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void EraseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight = mask > 0? 0 : currentHeight;
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void StripsBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    mask = mask > 0.0? 1.0 : 0.0;
   
    float2 uv = UVFromId(id, PATTERN_UV_REDZONE);
    uv = RotateUV(uv, BrushAngle);
    
    float wave = sqrt(max(sin((uv.x + 0.5) * BrushStripCount * PI * 2.0), 0));

    float newHeight = (wave * BrushHeight) * mask;

    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void RingsBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void CurveyStripsBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void SpiralBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void DoubleSpiralBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32,32,1)]
void PatternEraseBrush(uint3 id: SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void PaintBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void WaterBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void MaskHeightmap(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float mask = HeightmapMaskTexture.Load(int3(id.x, id.y, 0));
    float height = HeightmapTexture.Load(int3(id.x, id.y, 0));
    
    mask = mask > 0.0 ? 1.0 : 0.0;
    
    float newHeight = height * mask;
    
    OutputHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void Compose(uint3 id : SV_DispatchThreadID)
{   
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float baseHeight = HeightmapTexture.Load(int3(id.x, id.y, 0));
    float compositiveHeight = CompositiveHeightmapTexture.Load(int3(id.x, id.y, 0));
    
    float newHeight = baseHeight + compositiveHeight;
    
    //newHeight = clamp(newHeight, 0, 0.5);
    OutputHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32, 1)]
void Tween(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }
    
    float targetHeight = HeightmapTexture.Load(int3(id.x, id.y, 0));
    float currentHeight = TweenStateHeightmap.Load(int3(id.x, id.y, 0));
    
    float newHeight = lerp(currentHeight, targetHeight, DeltaTime * TweenStrength);
    
    newHeight = clamp(newHeight, 0, 0.5);
    OutputHeightmapTexture[id.xy] = newHeight;
}

[numthreads(32, 32,1)]
void ComputeNormals(uint3 id : SV_DispatchThreadID)
{
    uint2 limits;
    HeightmapTexture.GetDimensions(limits.x, limits.y);
    if (id.x >= limits.x || id.y >= limits.y)
    {
        return;
    }

    int2 p = int2(id.xy);

    float hL = HeightmapTexture.Load(int3(p + int2(-1, 0), 0));
    float hR = HeightmapTexture.Load(int3(p + int2(1, 0), 0));
    float hD = HeightmapTexture.Load(int3(p + int2(0, -1), 0));
    float hU = HeightmapTexture.Load(int3(p + int2(0, 1), 0));

    float dx = (hL - hR) * TerrainSize.x;
    float dy = 2.0 * TerrainSize.y;
    float dz = (hD - hU) * TerrainSize.z;

    //float3 normal = normalize(float3(dx, dy, dz));
    //NormalmapTexture[p] = float4(normal * 0.5 + 0.5, 1.0); // Convert to [0,1] range
    
    float3 normal = normalize(float3(dx, dy, dz));
    float3 encoded = normal * 0.5 + 0.5; // [-1,1] to [0,1]

    // Swizzle to match A2B10G10R10 layout: R -> Z, G -> Y, B -> X
    NormalmapTexture[p] = float4(encoded.z, encoded.y, encoded.x, 1.0);
}

[numthreads(32, 32, 1)]
void TessellateGridMesh(uint3 id: SV_DispatchThreadID)
{
    uint gridWidth = GridCellCount.x + 1;
    uint gridHeight = GridCellCount.y + 1;

    if (id.x >= gridWidth || id.y >= gridHeight)
        return;

    uint vertexIndex = id.y * gridWidth + id.x;

    // Compute world position
    float xPos = GridMeshWorldPosition.x + (id.x * GridCellSize);
    float zPos = GridMeshWorldPosition.y + (id.y * GridCellSize);

    // Compute UV (for visualization / texturing)
    float u = (float) id.x / GridCellCount.x;
    float v = (float) id.y / GridCellCount.y;
    
    OutputMeshUVs[vertexIndex] = float2(u, v);

    // Heightmap texel coordinates
    uint2 texelCoord = GridHightmapTexelPosition + uint2(id.x, id.y);

    // Sample height value
    float height = HeightmapTexture.Load(int3(texelCoord, 0));
    height *= TerrainSize.y * 2.0;
    

    OutputMeshVertices[vertexIndex] = float3(xPos, height, zPos);

    // Skip triangle generation if on last row/column
    if (id.x >= GridCellCount.x || id.y >= GridCellCount.y)
        return;

    // Triangle indices
    uint baseVertex = id.y * gridWidth + id.x;
    uint baseIndex = (id.y * GridCellCount.x + id.x) * 6;

    uint i0 = baseVertex;
    uint i1 = baseVertex + 1;
    uint i2 = baseVertex + gridWidth;
    uint i3 = baseVertex + gridWidth + 1;

    OutputMeshIndices[baseIndex + 0] = i0;
    OutputMeshIndices[baseIndex + 1] = i2;
    OutputMeshIndices[baseIndex + 2] = i1;

    OutputMeshIndices[baseIndex + 3] = i1;
    OutputMeshIndices[baseIndex + 4] = i2;
    OutputMeshIndices[baseIndex + 5] = i3;
}