#pragma kernel RaiseBrush
#pragma kernel LowerBrush
#pragma kernel SmoothBrush
#pragma kernel FlatBrush
#pragma kernel EraseBrush

#pragma kernel StripsBrush
#pragma kernel RingsBrush
#pragma kernel CurveyStripsBrush
#pragma kernel SpiralBrush
#pragma kernel DoubleSpiralBrush

#pragma kernel PaintBrush

#pragma kernel MaskHeightmap

Texture2D<float> HeightmapMaskTexture;
RWTexture2D<float> OutputHeightmapTexture;



Texture2D<float> HeightmapTexture;

Texture2D<float> BrushHeightmapTexture;

Texture2D<float> BrushMaskTexture;
SamplerState pointClampBrushMaskTextureSampler
{
    Filter = MIN_MAG_MIP_POINT;
    AddressU = Clamp;
    AddressV = Clamp;
};

RWTexture2D<float> OutputBrushHeightmapTexture;

int2 BrushPosition;

int2 BrushSize;
int2 ActualBrushSize;

float BrushStrength;
float BrushAngle;

float DeltaTime;

float BrushFlatHeight;

bool IsPointInRotatedBox(float2 boxPosition, int2 boxSize, float boxAngle, int2 target)
{
    // Convert angle to radians
    float angleRad = radians(boxAngle);
    float cosAngle = cos(angleRad);
    float sinAngle = sin(angleRad);

    // Calculate half sizes of the box
    float halfWidth = boxSize.x / 2.0f;
    float halfHeight = boxSize.y / 2.0f;

    // Step 1: Translate the point into the box's local space by subtracting the box position
    int2 translatedPoint = target - boxPosition;

    // Step 2: Rotate the point by the inverse of the box's angle
    float rotatedX = translatedPoint.x * cosAngle + translatedPoint.y * sinAngle;
    float rotatedY = -translatedPoint.x * sinAngle + translatedPoint.y * cosAngle;

    // Step 3: Check if the rotated point is within the box's unrotated bounds
    bool isInside = (rotatedX >= -halfWidth && rotatedX <= halfWidth) &&
                    (rotatedY >= -halfHeight && rotatedY <= halfHeight);

    return isInside;
}

bool IsCulled(uint3 id)
{
    if ((int) id.x >= ActualBrushSize.x || (int) id.y >= ActualBrushSize.y)
    {
        return true;
    }
    
    if (IsPointInRotatedBox(ActualBrushSize * 0.5, BrushSize, BrushAngle, id.xy) == false)
    {
        return true;
    }
    
    return false;
}

float GetBrushMaskValue(uint3 id)
{
    float2 offset = (ActualBrushSize - BrushSize) * 0.5;
    float2 uv = (float2(id.xy) - offset) / float2(BrushSize);
    
    float color = BrushMaskTexture.SampleLevel(pointClampBrushMaskTextureSampler, uv, 0);
    return color;
}

[numthreads(32, 32,1)]
void RaiseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight += BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void LowerBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight -= BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void SmoothBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float mask = GetBrushMaskValue(id);
    
    float accumulation = 0;
    const uint sampleCount = 9;
    
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
                                                                   
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
                                                                   
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    accumulation += BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    
    float newHeight = accumulation / (float)sampleCount;
    
    newHeight = clamp(newHeight, 0, 0.5);
    OutputBrushHeightmapTexture[id.xy] = newHeight/;
}

[numthreads(32, 32, 1)]
void FlatBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight += BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    currentHeight = clamp(currentHeight, 0, BrushFlatHeight);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void EraseBrush(uint3 id : SV_DispatchThreadID)
{
    if (IsCulled(id))
    {
        return;
    }
    
    float currentHeight = BrushHeightmapTexture.Load(int3(id.x, id.y, 0));
    float mask = GetBrushMaskValue(id);
    
    currentHeight -= BrushStrength * DeltaTime * mask;
    currentHeight = clamp(currentHeight, 0, 0.5);
    
    OutputBrushHeightmapTexture[id.xy] = currentHeight;
}

[numthreads(32, 32, 1)]
void StripsBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void RingsBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void CurveyStripsBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void SpiralBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void DoubleSpiralBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void PaintBrush(uint3 id : SV_DispatchThreadID)
{
    
}

[numthreads(32, 32, 1)]
void MaskHeightmap(uint3 id : SV_DispatchThreadID)
{
    
}